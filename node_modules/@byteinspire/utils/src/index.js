const crypto = require('crypto');

function _sign(data, key) {
    let hmac = crypto.createHmac('sha256', key);
    hmac.update(data);
    let sign = hmac.digest('base64');
    return sign;
}

function _requestInterceptor(config) {
    if (!config.authInfo) {
        return config;
    }
    const { serviceId, serviceSecret } = config.authInfo;
    let timestamp = Date.now() + '';
    let nonce = crypto.randomBytes(10).toString('hex');
    let str = `light\n${timestamp}\n${nonce}\nlight`;
    let sign = _sign(str, serviceSecret);
    let headers = {
        'x-light-service-id': serviceId,
        'x-light-timestamp': timestamp,
        'x-light-nonce': nonce,
        'x-light-sign': sign,
    };
    Object.assign(config.headers, headers);
    return config;
}

function trap(fn, containOriginStack = false, messageGenerator = (error) => error.message) {
    let trappedFn;
    function formatError(baseError, error) {
        baseError.message = messageGenerator(error); // eslint-disable-line no-param-reassign
        if (containOriginStack && baseError.stack) {
            baseError.stack += error.stack; // eslint-disable-line no-param-reassign
        }
        return baseError;
    }
    if (fn.constructor.name === 'AsyncFunction') {
        trappedFn = async function (...args) {
            const baseError = new Error('');
            try {
                // @ts-ignore
                const res = await fn.apply(this, args);
                return res;
            } catch (error) {
                throw formatError(baseError, error);
            }
        };
    } else {
        trappedFn = function (...args) {
            const baseError = new Error('');
            try {
                // @ts-ignore
                const res = fn.apply(this, args);
                if (res instanceof Promise) {
                    return res.catch((error) => {
                        throw formatError(baseError, error);
                    });
                }
                return res;
            } catch (error) {
                throw formatError(baseError, error);
            }
        };
    }
    Object.defineProperty(trappedFn, 'name', { value: fn.name });
    return trappedFn;
}

function trapped(containOriginStack, messageGenerator) {
    return function (target, propertyKey, desciptor) {
        if (desciptor.value) {
            desciptor.value = trap(desciptor.value, containOriginStack, messageGenerator); // eslint-disable-line no-param-reassign
        }
    };
}

function patchAxiosInstance(axiosInstance, serviceId, serviceSecret) {
    if (!axiosInstance.defaults) {
        axiosInstance.defaults = {};
    }
    axiosInstance.defaults.authInfo = {
        serviceId,
        serviceSecret,
    };
    axiosInstance.interceptors.request.use(_requestInterceptor);
    return axiosInstance;
}

function decrypt(data, key, iv = '') {
    if (!data) {
        return '';
    }
    const clearEncoding = 'utf8';
    const cipherEncoding = 'base64';
    const cipherChunks = [];
    const decipher = crypto.createDecipheriv('aes-256-ecb', key, iv);
    decipher.setAutoPadding(true);
    cipherChunks.push(decipher.update(data, cipherEncoding, clearEncoding));
    cipherChunks.push(decipher.final(clearEncoding));
    return cipherChunks.join('');
}

module.exports = {
    trap,
    trapped,
    decrypt,
    patchAxiosInstance,
};
