import { ObjectId } from 'bson';
export default DbSDK;

declare const DbSDK: SDK.ISDK;
export type API = SDK.IDBSDK;
export type ITable<T = any> = SDK.ITable<T>;
export type IEntity = SDK.IEntity;

declare namespace SDK {
    interface ISDK {
        createDbSDK(serviceId: string, axiosInstance: any): IDBSDK;
    }

    interface IDBSDK {
        table<DBModel = any>(tableName: string): ITable<DBModel>;

        ObjectId: typeof ObjectId;


        eq(data: any): IDBSDK;
        ne(data: any): IDBSDK;
        gt(data: any): IDBSDK;
        gte(data: any): IDBSDK;
        lt(data: any): IDBSDK;
        lte(data: any): IDBSDK;
        in(data: any[]): IDBSDK;
        nin(data: any[]): IDBSDK;

        and(...data: any[]): IDBSDK;
        or(...data: any[]): IDBSDK;
        nor(...data: any[]): IDBSDK;
        not(data: any): IDBSDK;

        exists(existance: boolean): IDBSDK;
        mod(modExpr: [number, number]): IDBSDK;
        regex(reg: RegExp): IDBSDK;
        all(element: any[]): IDBSDK;
        elemMatch(expr: any): IDBSDK;
        size(n: number): IDBSDK;

        bitsAllClear(bitPos: number[]): IDBSDK;
        bitsAllSet(bitPos: number[]): IDBSDK;
        bitsAnyClear(bitPos: number[]): IDBSDK;
        bitsAnySet(bitPos: number[]): IDBSDK;

        geoIntersects(geoObjExpr: any): IDBSDK;
        geoWithin(geoObjExpr: any): IDBSDK;
        near(geoObjExpr: any): IDBSDK;
        nearSphere(geoObjExpr: any): IDBSDK;

        literal(constant: any): IDBSDK;

        abs(expr: any): IDBSDK;
        add(exprs: any[]): IDBSDK;
        cmp(expr: [any, any]): IDBSDK;
        ceil(expr: any): IDBSDK;
        divide(expr: [any, any]): IDBSDK;
        exp(expr: any): IDBSDK;
        floor(expr: any): IDBSDK;
        ln(expr: any): IDBSDK;
        log(expr: [any, any]): IDBSDK;
        log10(expr: any): IDBSDK;
        mod(expr: [any, any]): IDBSDK;
        multiply(expr: any[]): IDBSDK;
        pow(expr: [any, any]): IDBSDK;
        round(expr: any): IDBSDK;
        sqrt(expr: any): IDBSDK;
        subtract(expr: [any, any]): IDBSDK;
        cond(condIfElse: [any, any, any]): IDBSDK;
        ifNull(condIfNull: [any, any]): IDBSDK;
        switch(branches: { cases: { case: any; then: any }[]; default: any }): IDBSDK;

        dayOfMonth(expr: any): IDBSDK;
        dayOfWeek(expr: any): IDBSDK;
        dayOfYear(expr: any): IDBSDK;
        hour(expr: any): IDBSDK;
        millisecond(expr: any): IDBSDK;
        minute(expr: any): IDBSDK;
        month(expr: any): IDBSDK;
        second(expr: any): IDBSDK;
        week(expr: any): IDBSDK;
        year(expr: any): IDBSDK;

        concat(expr: any[]): IDBSDK;
        dateFromString(expr: {
            dateString: string;
            format: string;
            timezone: string;
            onError: any;
            onNull: any;
        }): IDBSDK;

        dateToString(expr: {
            format: string;
            date: string;
            timezone: string;
            onError: any;
        }): IDBSDK;
        indexOfBytes(expr: [any, any, number, number]): IDBSDK;
        indexOfCP(expr: [any, any, number, number]): IDBSDK;
        ltrim(expr: any): IDBSDK;
        rtrim(expr: any): IDBSDK;
        split(expr: [any, string]): IDBSDK;
        strLenBytes(expr: any): IDBSDK;
        strLenCP(expr: any): IDBSDK;
        strcasecmp(expr: any[]): IDBSDK;
        substrBytes(expr: [any, number, number]): IDBSDK;
        substrCP(expr: [any, number, number]): IDBSDK;
        toLower(expr: any): IDBSDK;
        toString(expr: any): IDBSDK;
        toUpper(expr: any): IDBSDK;
        trim(expr: any): IDBSDK;
    }

    interface IEntity {
        _id: ObjectId;
        createdAt: Date;
        updatedAt: Date;
    }

    interface ITable<DBModel = any> {
        create<T extends Partial<DBModel>>(obj: T): T & IEntity;
        create<T extends Partial<DBModel>>(obj: T[]): (T & IEntity)[];
        save<T extends Partial<DBModel>>(obj: T): Promise<T & IEntity>;
        save<T extends Partial<DBModel>>(obj: T[]): Promise<(T & IEntity)[]>;
        where(field: string): IQuery<DBModel>;
        where(filter: Object): IQuery<DBModel>;
        where(): IQuery<DBModel>;
        delete(
            obj: Partial<DBModel> | Partial<DBModel>[],
        ): Promise<{
            result: { deletedCount: number };
        }>;
    }

    interface ISet {
        upsert(): ISet;
        save(): Promise<{
            updatedCount: number;
            upsertedCount: number;
            upsertedId: ObjectId | null;
        }>;
        // 注意，Set 这里只有 limit 可以用。skip, sort 等都无效。
        limit(n: number): ISet;

        set(value: any): ISet;
        setOnInsert(value: any): ISet;
        to(value: any): ISet;
        max(value: number): ISet;
        min(value: number): ISet;
        mul(value: number): ISet;
        multiply(value: number): ISet;
        inc(value: number): ISet;
        increment(value: number): ISet;
        currentDate(): ISet;
        multiply(value: number): ISet;
        rename(column: string): ISet;
    }

    interface IAggregationQuery {
        find(): Promise<any[]>;
        findOne(): Promise<any>;
        count(): Promise<number>;
        where(): IQuery<any>;
        where(field: string): IQuery<any>;
        where(filter: Object): IQuery<any>;

        sum(field: string): IAggregationQuery;
        sum(exp: Object): IAggregationQuery;
        as(field: string): IAggregationQuery;
        avg(field: string): IAggregationQuery;
        avg(exp: Object): IAggregationQuery;
        max(field: string): IAggregationQuery;
        max(exp: Object): IAggregationQuery;
        min(field: string): IAggregationQuery;
        min(exp: Object): IAggregationQuery;
        mul(field: string): IAggregationQuery;
        mul(exp: Object): IAggregationQuery;
        stdDevPop(field: string): IAggregationQuery;
        stdDevPop(exp: Object): IAggregationQuery;
        stdDevSamp(field: string): IAggregationQuery;
        stdDevSamp(exp: Object): IAggregationQuery;
        first(field: string): IAggregationQuery;
        first(exp: Object): IAggregationQuery;
        last(field: string): IAggregationQuery;
        last(exp: Object): IAggregationQuery;
        num(): IAggregationQuery;

        mergeToArray(field: Object): IAggregationQuery;
        mergeToSet(field: Object): IAggregationQuery;
        mergeToObject(field: Object): IAggregationQuery;
    }

    interface IPopulateOption<DBModel, RefKey extends keyof DBModel> {
        ref: RefKey;
        populate?: any;
    }

    interface IQuery<DBModel = any> {
        count(): Promise<number>;
        find(): Promise<Array<DBModel & IEntity>>;
        findOne(): Promise<DBModel & IEntity>;
        delete(): Promise<{
            result: { deletedCount: number };
        }>;
        limit(value: number): IQuery<DBModel>;
        skip(value: number): IQuery<DBModel>;
        sort(value: Partial<Record<keyof (DBModel & IEntity), -1 | 1>>): IQuery<DBModel>;
        projection(filter: Partial<Record<keyof (DBModel & IEntity), 1 | -1>>): IQuery<any>;
        where(value: any): IQuery<DBModel>;

        or(...filter: any[]): IQuery<DBModel>;
        and(...filter: any[]): IQuery<DBModel>;
        nor(...filter: any[]): IQuery<DBModel>;

        populate(field: keyof DBModel): IQuery<DBModel>;
        populate<Field extends keyof DBModel>(option: IPopulateOption<DBModel, Field>): IQuery<DBModel>;
        populate(fieldOrOptions: any[]): IQuery<DBModel>;

        // start a IAggregationQuery
        groupBy(o: Object): IAggregationQuery;
        groupBy(): IAggregationQuery;

        // start a ISet
        set(value?: string): ISet;
        set(object: Partial<DBModel>): ISet;
        replace(value: Object): ISet;

        // operations
        gt(value: any): IQuery<DBModel>;
        greaterThan(value: any): IQuery<DBModel>;
        gte(value: any): IQuery<DBModel>;
        greaterThanOrEquals(value: any): IQuery<DBModel>;
        lt(value: any): IQuery<DBModel>;
        lessThan(value: any): IQuery<DBModel>;
        lte(value: any): IQuery<DBModel>;
        lessThanOrEquals(value: any): IQuery<DBModel>;
        eq(value: any): IQuery<DBModel>;
        equals(value: any): IQuery<DBModel>;
        ne(value: any): IQuery<DBModel>;
        notEquals(value: any): IQuery<DBModel>;
        nin(array: Array<any>): IQuery<DBModel>;
        in(array: Array<any>): IQuery<DBModel>;
        hint(column: string): IQuery<DBModel>;
        notIn(array: Array<any>): IQuery<DBModel>;
        as(alias: string): IQuery<DBModel>;
        regex(regex: RegExp): IQuery<DBModel>;
    }
}
