const { format } = require('util');
const utils = require('./helpers/utils');
const s = require('./symbols');
const { trap } = require('@byteinspire/utils');
const _ = require('lodash');
const operatable = require('./operatable');

class Query {
    constructor(table) {
        this.table = table;
        this.options = {};
        this.query = {};
        this.update = {};
        this.mode = 'crud';
        this.pipeline = [];
        this.stage = { type: 'matchGeneral', match: this.query };
        this.pipeline.push(this.stage);

        this.populateSpec = [];
    }

    _query(obj) {
        if (!obj) {
            return;
        }
        for (let [k, v] of Object.entries(obj)) {
            if (v && v[s.table]) {
                this.query[k] = v;
            } else if (utils.isPlainObject(v)) {
                this.query[k] = this.query[k] || {};
                if (!utils.isPlainObject(this.query[k])) {
                    if (utils.isRegex(this.query[k])) {
                        this.query[k] = { $regex: this.query[k] };
                    } else {
                        this.query[k] = { $eq: this.query[k] };
                    }
                }

                let shouldUseAnd = false;
                for (let key of Object.keys(this.query[k])) {
                    if (v[key] !== undefined) {
                        shouldUseAnd = true;
                    }
                }
                if (shouldUseAnd) {
                    this.and({ [k]: v });
                } else {
                    Object.assign(this.query[k], v);
                }
            } else {
                if (this.query[k] !== undefined) {
                    this.and({ [k]: v });
                } else {
                    this.query[k] = v;
                }
            }
        }
    }

    _update(obj) {
        if (!obj) {
            return;
        }
        for (let [k, v] of Object.entries(obj)) {
            this.update[k] = this.update[k] || {};
            Object.assign(this.update[k], v);
        }
    }

    _option(obj) {
        Object.assign(this.options, obj);
    }

    async count() {
        if (this.mode === 'crud') {
            let newQuery = {};
            utils.detectODMInQueryAndTransform(this.query, newQuery);
            this.query = newQuery;
            let result = await this.table._send({
                op: 'count',
                query: this.query,
                ...this.options,
            });
            return result;
        } else {
            this.pipeline.push({
                type: 'group',
                group: {
                    _id: null,
                    count: { $sum: 1 },
                },
            });

            let objs = await this.table._send({
                op: 'aggregate',
                pipeline: this.pipeline,
            });
            if (!objs[0]) return 0;
            return objs[0].count;
        }
    }

    async find() {
        // eslint-disable-next-line
        return this._find();
    }

    _normalizePopulateSpec() {
        this.populateSpec = normalize(this.populateSpec);

        function normalize(spec) {
            let normalizedSpec;
            if (Array.isArray(spec)) {
                normalizedSpec = [];
                for (let theSpec of spec) {
                    if (typeof theSpec === 'string' || utils.isPlainObject(theSpec)) {
                        let normalized = normalize(theSpec);
                        let index = normalizedSpec.findIndex((v) => v.ref === normalized.ref);
                        if (index !== -1) {
                            normalizedSpec.splice(index, 1);
                        }
                        normalizedSpec.push(normalized);
                    }
                }
                if (normalizedSpec.length === 0) return null;
                return normalizedSpec;
            } else if (typeof spec === 'string') {
                return { ref: spec };
            } else if (utils.isPlainObject(spec)) {
                let theSpec = spec;
                let normalized = {};
                if (typeof theSpec.ref !== 'string') {
                    // eslint-disable-next-line quotes
                    throw new Error(format("populate failed. please specify {ref: 'yourField'}, received:", theSpec));
                }
                normalized.ref = theSpec.ref;
                if (theSpec.table && theSpec.table.tableName) {
                    normalized.table = theSpec.table.tableName;
                } else if (typeof theSpec.table === 'string') {
                    normalized.table = theSpec.table;
                }
                if (theSpec.projection) {
                    normalized.projection = theSpec.projection;
                }
                if (theSpec.populate) {
                    let populate = normalize(theSpec.populate);
                    if (populate) {
                        if (!Array.isArray(populate)) {
                            populate = [populate];
                        }
                        normalized.populate = populate;
                    }
                }
                return normalized;
            }
            return null;
        }
    }

    async _populateForArray(odms, spec) {
        if (odms.length === 0 || spec.length === 0) {
            return;
        }
        await Promise.all(
            spec.map(async (theSpec) => {
                let { ref, table, projection, populate } = theSpec;

                let dbTable = this.table.lightDb.table(table);
                let ids = [];
                for (let odm of odms) {
                    let maybeId = _.get(odm, ref);

                    if (maybeId && utils.isObjectId(maybeId)) {
                        ids.push(maybeId);
                    } else if (Array.isArray(maybeId)) {
                        for (let item of maybeId) {
                            if (item && utils.isObjectId(item)) {
                                ids.push(item);
                            }
                        }
                    }
                }
                let promiseList = [];
                for (let i = 0; i < ids.length; i += 1000) {
                    let batchIds = ids.slice(i, i + 1000);
                    promiseList.push(
                        dbTable._send({
                            op: 'find',
                            query: { _id: { $in: batchIds } },
                            projection,
                        }),
                    );
                }
                let objs = [].concat(...(await Promise.all(promiseList)));

                let relateOdms = objs.map((v) => dbTable._createFromObject(v, false));
                let batchHash = {}; // {idStr: relateDoc}

                for (let doc of relateOdms) {
                    batchHash[doc._id.toString()] = doc;
                }
                for (let odm of odms) {
                    let maybeId = _.get(odm, ref);

                    if (maybeId && utils.isObjectId(maybeId)) {
                        _.set(odm, ref, batchHash[maybeId.toString()] || null);
                    } else if (Array.isArray(maybeId)) {
                        for (let i = 0; i < maybeId.length; i++) {
                            let item = maybeId[i];
                            if (item && utils.isObjectId(item)) {
                                maybeId[i] = batchHash[item.toString()] || null;
                            } else {
                                maybeId[i] = null;
                            }
                        }
                    } else {
                        _.set(odm, ref, null);
                    }
                    // 以上 populate 赋值操作不计入修改
                    // 为实现简单, 清空修改以达到此目的
                    odm[s.updates] = {};
                    odm[s.populatePaths][ref] = 1;
                }

                if (populate) {
                    await this._populateForArray(relateOdms, populate);
                }
            }),
        );
    }

    async _find({ one = false } = {}) {
        if (this.mode === 'crud') {
            this._normalizePopulateSpec();

            if (one) {
                this.options.limit = 1;
            }
            let newQuery = {};
            utils.detectODMInQueryAndTransform(this.query, newQuery);
            this.query = newQuery;
            let [objs, autofilledPopulateSpec] = await Promise.all([
                this.table._send({
                    op: 'find',
                    query: this.query,
                    ...this.options,
                }),
                this.populateSpec &&
                    this.table._send({
                        op: 'autofillPopulateSpec',
                        populateSpec: this.populateSpec,
                    }),
            ]);

            let odms = objs.map((v) => this.table._createFromObject(v, false));
            if (autofilledPopulateSpec) {
                await this._populateForArray(odms, autofilledPopulateSpec);
            }
            if (one) {
                if (odms[0]) return odms[0];
                return null;
            } else {
                return odms;
            }
        } else {
            if (one) {
                let pipeline = this.pipeline;
                let i = pipeline.length - 1;
                let current = pipeline[i];
                let { type } = current;
                if (type === 'matchGeneral') {
                    current.limit = 1;
                } else {
                    pipeline.push({ type: 'matchGeneral', limit: 1 });
                }
            }
            let objs = await this.table._send({
                op: 'aggregate',
                pipeline: this.pipeline,
            });
            if (one) {
                if (objs[0]) return objs[0];
                return null;
            } else {
                return objs;
            }
        }
    }

    async findOne() {
        // eslint-disable-next-line
        return this._find({ one: true });
    }

    async save() {
        if (this.update.$set && this.update.$set.updatedAt) {
        } else {
            this._update({
                $set: { updatedAt: new Date() },
            });
        }
        if (this.update.$setOnInsert && this.update.$setOnInsert.createdAt) {
        } else if (this.update.$set && this.update.$set.createdAt) {
        } else {
            this._update({
                $setOnInsert: { createdAt: new Date() },
            });
        }

        if (this.options.limit === 1) {
            this.options.one = true;
        }
        let detectedODMs = [];
        let detectedRefSchema = {};

        let newSet = {};
        let newSetOnInsert = {};
        utils.detectODMAndTransform(this.update.$set, newSet, detectedODMs, detectedRefSchema);
        utils.detectODMAndTransform(this.update.$setOnInsert, newSetOnInsert, detectedODMs, detectedRefSchema);

        if (Object.keys(newSet).length > 0) {
            this.update.$set = newSet;
        }
        if (Object.keys(newSetOnInsert).length > 0) {
            this.update.$setOnInsert = newSetOnInsert;
        }
        let promise = utils.save(detectedODMs);

        let ret = await this.table._send({
            op: 'update',
            query: this.query,
            update: this.update,
            ...this.options,
        });

        await promise;

        if (Object.keys(detectedRefSchema).length > 0) {
            await this.table._send({ op: 'saveDetectedRefSchema', detectedRefSchema });
        }

        return ret;
    }

    async delete() {
        if (this.options.limit === 1) {
            this.options.one = true;
        }
        // eslint-disable-next-line
        return this.table._send({
            op: 'delete',
            query: this.query,
            ...this.options,
        });
    }

    where(value) {
        if (this.stage.type === 'group') {
            this.stage = { type: 'matchGeneral', match: this.query };
            this.pipeline.push(this.stage);
        }
        if (value == null) {
        } else if (typeof value === 'string') {
            this.path = value;
        } else if (typeof value === 'function') {
            this._query({ $where: value });
        } else if (value[s.table]) {
            this._query({ _id: value._id });
        } else if (utils.isObjectId(value)) {
            this._query({ _id: value });
        } else if (Array.isArray(value)) {
            let ids = value.map((v) => v._id);
            this._query({ _id: { $in: ids } });
        } else {
            this._query(value);
        }
        return this;
    }

    and(...conditions) {
        this.query = operatable.and.call(this.query, ...conditions);
        return this;
    }

    or(...conditions) {
        this.query = operatable.or.call(this.query, ...conditions);
        return this;
    }

    nor(...conditions) {
        this.query = operatable.nor.call(this.query, ...conditions);
        return this;
    }

    equals(value) {
        if (!this.path) return this;
        this._query({ [this.path]: { $eq: value } });
        return this;
    }

    regex(value) {
        if (!this.path) return this;
        this._query({ [this.path]: { $regex: value } });
        return this;
    }

    eq(value) {
        if (!this.path) return this;
        this._query({ [this.path]: { $eq: value } });
        return this;
    }

    notEquals(value) {
        if (!this.path) return this;
        this._query({ [this.path]: { $ne: value } });
        return this;
    }

    ne(value) {
        if (!this.path) return this;
        this._query({ [this.path]: { $ne: value } });
        return this;
    }

    lessThan(value) {
        if (!this.path) return this;
        this._query({ [this.path]: { $lt: value } });
        return this;
    }

    lt(value) {
        if (!this.path) return this;
        this._query({ [this.path]: { $lt: value } });
        return this;
    }

    lessThanOrEquals(value) {
        if (!this.path) return this;
        this._query({ [this.path]: { $lte: value } });
        return this;
    }

    lte(value) {
        if (!this.path) return this;
        this._query({ [this.path]: { $lte: value } });
        return this;
    }

    greaterThan(value) {
        if (!this.path) return this;
        this._query({ [this.path]: { $gt: value } });
        return this;
    }

    gt(value) {
        if (!this.path) return this;
        this._query({ [this.path]: { $gt: value } });
        return this;
    }

    greaterThanOrEquals(value) {
        if (!this.path) return this;
        this._query({ [this.path]: { $gte: value } });
        return this;
    }

    gte(value) {
        if (!this.path) return this;
        this._query({ [this.path]: { $gte: value } });
        return this;
    }

    in(arr) {
        if (!this.path) return this;
        this._query({ [this.path]: { $in: arr } });
        return this;
    }

    notIn(arr) {
        if (!this.path) return this;
        this._query({ [this.path]: { $nin: arr } });
        return this;
    }

    nin(arr) {
        if (!this.path) return this;
        this._query({ [this.path]: { $nin: arr } });
        return this;
    }

    near(geometry, max, min = 0) {
        if (!this.path) return this;
        this._query({
            [this.path]: {
                $near: {
                    $geometry: geometry,
                    $maxDistance: max,
                    $minDistance: min,
                },
            },
        });
        return this;
    }

    sort(value) {
        if (this.options.sort) {
            Object.assign(this.options.sort, value);
        } else {
            this.options.sort = value;
        }
        if (this.stage.sort) {
            Object.assign(this.stage.sort, value);
        } else {
            this.stage.sort = value;
        }
        return this;
    }

    limit(value) {
        this._option({ limit: value });
        this.stage.limit = value;
        return this;
    }

    skip(value) {
        this._option({ skip: value });
        this.stage.skip = value;
        return this;
    }

    hint(value) {
        this._option({ hint: value });
        return this;
    }

    projection(value) {
        this._option({ projection: value });
        this.stage.project = value;

        return this;
    }

    upsert(value) {
        this._option({ upsert: true });
        return this;
    }

    replace(value) {
        this._option({ replace: value });
        return this;
    }

    set(value) {
        if (typeof value === 'string') {
            this.upath = value;
        } else {
            let updateOp = {};
            Object.entries(value).forEach(([k, v]) => {
                if (k.startsWith('$')) {
                    updateOp[k] = v;
                } else {
                    updateOp.$set = updateOp.$set || {};
                    updateOp.$set[k] = v;
                }
            });
            this._update(updateOp);
        }
        return this;
    }

    to(value) {
        if (!this.upath) return this;
        this._update({ $set: { [this.upath]: value } });
        return this;
    }

    increment(value) {
        if (!this.upath) return this;
        this._update({ $inc: { [this.upath]: value } });
        return this;
    }

    inc(value) {
        if (!this.upath) return this;
        this._update({ $inc: { [this.upath]: value } });
        return this;
    }

    multiply(value) {
        if (!this.upath) return this;
        this._update({ $mul: { [this.upath]: value } });
        return this;
    }

    mul(value) {
        if (!this.upath) return this;
        this._update({ $mul: { [this.upath]: value } });
        return this;
    }

    min(value) {
        if (this.mode === 'crud') {
            if (!this.upath) return this;
            this._update({ $min: { [this.upath]: value } });
            return this;
        } else {
            return this.groupOp(value, 'min');
        }
    }

    max(value) {
        if (this.mode === 'crud') {
            if (!this.upath) return this;
            this._update({ $max: { [this.upath]: value } });
            return this;
        } else {
            return this.groupOp(value, 'max');
        }
    }

    currentDate() {
        if (!this.upath) return this;
        this._update({ $currentDate: { [this.upath]: true } });
        return this;
    }

    rename(value) {
        if (!this.upath) return this;
        this._update({ $rename: { [this.upath]: value } });
        return this;
    }

    unset() {
        if (!this.upath) return this;
        this._update({ $unset: { [this.upath]: '' } });
        return this;
    }

    setOnInsert(value) {
        this._update({ $setOnInsert: value });
        return this;
    }

    groupBy(field) {
        if (this.mode !== 'aggregation') {
            this.mode = 'aggregation';
            let newQuery = {};
            utils.detectODMInQueryAndTransform(this.query, newQuery);
            this.stage.match = newQuery;
            this.query = {};
        }
        this.stage = { type: 'group', group: {} };
        this.pipeline.push(this.stage);
        if (field == null) {
            this.stage.group._id = null;
        } else {
            let autoAs;
            if (typeof field === 'string') {
                autoAs = field;

                field = '$' + field;
            } else {
                autoAs = JSON.stringify(field);
            }

            this.asForGroupBy = true;
            this.stage.idAlias = autoAs;

            this.stage.group._id = field;
        }
        return this;
    }

    as(alias) {
        if (this.asForGroupBy) {
            this.stage.idAlias = alias;
        } else {
            let value = this.stage.group[this.opAs];
            delete this.stage.group[this.opAs];
            this.stage.group[alias] = value;
        }
        return this;
    }

    groupOp(field, op) {
        this.opAs = `${op}(${JSON.stringify(field)})`;
        this.asForGroupBy = false;

        let opName = '$' + op;
        if (op === 'num') {
            this.opAs = `${op}()`;
            opName = '$sum';
            field = 1;
        } else if (op === 'mergeToArray') {
            opName = '$push';
        } else if (op === 'mergeToSet') {
            opName = '$addToSet';
        } else if (op === 'mergeToObject') {
            opName = '$mergeObjects';
        }
        if (typeof field === 'string') {
            field = '$' + field;
        }
        this.stage.group[this.opAs] = { [opName]: field };
        return this;
    }

    sum(field) {
        return this.groupOp(field, 'sum');
    }

    avg(field) {
        return this.groupOp(field, 'avg');
    }

    stdDevPop(field) {
        return this.groupOp(field, 'stdDevPop');
    }

    stdDevSamp(field) {
        return this.groupOp(field, 'stdDevSamp');
    }

    first(field) {
        return this.groupOp(field, 'first');
    }

    last(field) {
        return this.groupOp(field, 'last');
    }

    mergeToArray(field) {
        return this.groupOp(field, 'mergeToArray');
    }

    mergeToSet(field) {
        return this.groupOp(field, 'mergeToSet');
    }

    mergeToObject(field) {
        return this.groupOp(field, 'mergeToObject');
    }

    num() {
        return this.groupOp(null, 'num');
    }

    populate(spec) {
        if (typeof spec === 'string') {
            this.populateSpec.push(spec);
        } else if (Array.isArray(spec)) {
            this.populateSpec.push(...spec);
        } else if (utils.isPlainObject(spec)) {
            this.populateSpec.push(spec);
        }
        return this;
    }
}

const toDecorate = ['find', 'count', 'save', 'findOne', 'delete'];

toDecorate.map((operationName) => {
    const descriptor = Object.getOwnPropertyDescriptor(Query.prototype, operationName);
    descriptor.value = trap(
        descriptor.value,
        false,
        (error) => `[inspirecloud.db.table.${operationName}]: ${error.message}`,
    );
    Object.defineProperty(Query.prototype, operationName, descriptor);
});

module.exports = Query;
