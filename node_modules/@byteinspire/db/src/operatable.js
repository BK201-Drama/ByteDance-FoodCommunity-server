const valid = require('./helpers/valid');
const utils = require('./helpers/utils');
const s = require('./symbols');
let operatable = {};
module.exports = operatable;

const specs = {
    eq: 'any',
    ne: 'any',
    gt: 'any',
    gte: 'any',
    lt: 'any',
    lte: 'any',
    in: 'arr',
    nin: 'arr',
    not: 'any',
    exists: 'any',
    mod: 'arr',
    regex: 'any',
    all: 'arr',
    elemMatch: 'obj',
    size: 'int',
    bitsAllClear: 'arr',
    bitsAllSet: 'arr',
    bitsAnyClear: 'arr',
    bitsAnySet: 'arr',
    geoIntersects: 'obj',
    geoWithin: 'obj',
    near: 'obj',
    nearSphere: 'obj',
    literal: 'any',
    abs: 'any',
    add: 'arr',
    ceil: 'any',
    divide: 'arr',
    exp: 'any',
    floor: 'any',
    ln: 'any',
    log: 'arr',
    log10: 'any',
    multiply: 'arr',
    pow: 'arr',
    round: 'any',
    sqrt: 'any',
    subtract: 'any',
    trunc: 'any',
    cmp: 'arr',
    cond: 'arr',
    ifNull: 'arr',
    switch: 'obj',
    dayOfMonth: 'any',
    dayOfWeek: 'any',
    dayOfYear: 'any',
    hour: 'any',
    millisecond: 'any',
    minute: 'any',
    month: 'any',
    second: 'any',
    week: 'any',
    year: 'any',
    concat: 'arr',
    dateFromString: 'obj',
    dateToString: 'obj',
    indexOfBytes: 'arr',
    indexOfCP: 'arr',
    ltrim: 'any',
    rtrim: 'any',
    split: 'arr',
    strLenBytes: 'any',
    strLenCP: 'any',
    strcasecmp: 'arr',
    substrBytes: 'arr',
    substrCP: 'arr',
    toLower: 'any',
    toString: 'any',
    toUpper: 'any',
    trim: 'any',
};

for (let [k, v] of Object.entries(specs)) {
    Object.defineProperty(operatable, k, {
        enumerable: false,
        value: function (exp) {
            valid(v, exp);

            let origin;
            if (this[s.isRootOperatable]) {
                origin = {};
            } else {
                origin = this;
            }

            let operator = {};
            Object.setPrototypeOf(operator, operatable);
            return Object.assign(operator, origin, { [`$${k}`]: exp });
        },
    });
}
const logicOps = ['and', 'nor', 'or'];
for (let k of logicOps) {
    Object.defineProperty(operatable, k, {
        enumerable: false,
        value: function (...conditions) {
            if (this[s.isRootOperatable]) {
            } else if (utils.isPlainObject(this) && Object.keys(this).length > 0) {
                conditions = [this, ...conditions];
            }

            let operator = {};
            Object.setPrototypeOf(operator, operatable);
            return Object.assign(operator, { [`$${k}`]: conditions });
        },
    });
}
