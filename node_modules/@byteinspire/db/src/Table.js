const { trap } = require('@byteinspire/utils');
const utils = require('./helpers/utils');
const ODMObject = require('./ODMObject');
const Query = require('./Query');
const ObjectId = require('bson').ObjectId;
const s = require('./symbols');
const valid = require('./helpers/valid');
const util = require('util');

class Table {
    constructor(tableName, serviceId, lightDb) {
        this.lightDb = lightDb;
        this.serviceId = serviceId;
        this.tableName = tableName;
    }

    async createIndex(key, options = {}) {
        // noinspection all
        let ret = await this._send({
            op: 'createIndexes',
            indexSpecs: { key, ...options },
        });
        return ret;
    }
    create(obj) {
        return this._create(obj);
    }

    _create(obj, isNew = true) {
        if (Array.isArray(obj)) {
            return obj.map((v) => this._createFromObject(v, isNew));
        } else if (utils.isPlainObject(obj)) {
            return this._createFromObject(obj, isNew);
        } else {
            throw new Error(util.format('Expected a value of type `object` or `array` but received:', obj));
        }
    }

    _createFromObject(obj, isNew = true) {
        if (util.types.isProxy(obj) && obj[s.table]) {
            if (obj[s.table] !== this) {
                return ODMObject(ODMObject.origin(obj), { table: this, isNew });
            } else {
                return obj;
            }
        }
        if (!utils.isPlainObject(obj)) {
            throw new Error('must only create from object');
        }
        if (isNew) {
            obj._id = obj._id || ObjectId();
        }
        return ODMObject(obj, { table: this, isNew });
    }

    where() {
        return new Query(this).where(...arguments);
    }

    async _send(instruction) {
        let newInstruction = Object.assign(
            {
                serviceId: this.serviceId,
                collection: this.tableName,
            },
            instruction,
        );
        // eslint-disable-next-line
    return this.lightDb.database.send(newInstruction)
    }

    async _saveMany(odmArgs) {
        let odms = [];

        // 拦住同一对象多次 save
        for (let odmArg of odmArgs) {
            if (!odmArg[s.saving]) {
                odmArg[s.saving] = true;
                odms.push(odmArg);
            }
        }
        try {
            let instructions = [];
            let detectedODMs = [];
            let detectedRefSchema = {};

            for (let i = 0; i < odms.length; i++) {
                let odm = odms[i];

                if (odm[s.isNew]) {
                    odm.createdAt = odm.createdAt !== undefined ? odm.createdAt : new Date();
                    odm.updatedAt = odm.updatedAt !== undefined ? odm.updatedAt : new Date();

                    let docs = ODMObject.origin(odm);
                    let transformedDocs = {};
                    utils.detectODMAndTransform(docs, transformedDocs, detectedODMs, detectedRefSchema);

                    instructions.push({ op: 'insert', docs: transformedDocs });
                } else {
                    let updateField = ODMObject.genUpdateField(odm);
                    utils.detectODM(odm, detectedODMs, detectedRefSchema);

                    let newSet = {};
                    utils.detectODMAndTransform(updateField.$set, newSet, detectedODMs);
                    if (Object.keys(newSet).length > 0) {
                        updateField.$set = newSet;
                    }

                    if (Object.keys(updateField).length === 0) {
                        instructions.push(null);
                    } else {
                        if (updateField.$set && updateField.$set.updatedAt) {
                        } else {
                            let updatedAt = new Date();
                            updateField.$set = updateField.$set || {};
                            updateField.$set.updatedAt = updatedAt;
                            odm.updatedAt = updatedAt;
                        }

                        if (odm._id == null) {
                            throw new Error('cannot save item with no `_id` field');
                        }

                        instructions.push({
                            op: 'update',
                            query: { _id: odm._id },
                            one: true,
                            update: updateField,
                        });
                    }
                }
            }

            let promise = utils.save(detectedODMs);

            let instructionsToSend = instructions.filter((v) => v);

            if (instructionsToSend.length > 0) {
                await this._send({
                    op: 'bulkWrite',
                    instructions: instructionsToSend,
                });
            }

            await promise;

            if (Object.keys(detectedRefSchema).length > 0) {
                await this._send({ op: 'saveDetectedRefSchema', detectedRefSchema });
            }

            for (let i = 0; i < odms.length; i++) {
                if (instructions[i] == null || instructions[i].op === 'update') {
                    odms[i][s.updates] = {};
                } else {
                    odms[i][s.isNew] = false;
                }
            }
        } finally {
            odmArgs.forEach((v) => {
                v[s.saving] = false;
            });
        }

        return odmArgs;
    }

    async save(obj) {
        if (Array.isArray(obj)) {
            valid(['obj'], obj);

            // eslint-disable-next-line
      return this._saveMany(obj.map(v => this._createFromObject(v)))
        } else {
            valid('obj', obj);

            let [ret] = await this._saveMany([this._createFromObject(obj)]);
            return ret;
        }
    }

    async delete(obj) {
        if (Array.isArray(obj)) {
            valid(['obj'], obj);

            let ids = obj.map((v) => {
                if (v[s.table] !== this) {
                    throw new Error('cannot delete from this table');
                }
                if (v._id == null) {
                    throw new Error('cannot delete item with no `_id` field');
                }
                return v._id;
            });
            let ret = await this._send({ op: 'delete', query: { _id: { $in: ids } } });
            obj.forEach((v) => {
                v[s.isNew] = true;
                v[s.updates] = {};
            });
            return ret;
        } else {
            valid('obj', obj);

            if (obj[s.table] !== this) {
                throw new Error('cannot delete from this table');
            }
            if (obj._id == null) {
                throw new Error('cannot delete item with no `_id` field');
            }
            let ret = await this._send({
                op: 'delete',
                one: true,
                query: { _id: obj._id },
            });
            obj[s.isNew] = true;
            obj[s.updates] = {};
            return ret;
        }
    }
}

const toDecorate = ['save', 'delete', 'createIndex'];

toDecorate.map((operationName) => {
    const descriptor = Object.getOwnPropertyDescriptor(Table.prototype, operationName);
    if (descriptor) {
        descriptor.value = trap(
            descriptor.value,
            false,
            (error) => `[inspirecloud.db.table.${operationName}]: ${error.message}`,
        );
        Object.defineProperty(Table.prototype, operationName, descriptor);
    }
});
module.exports = Table;
