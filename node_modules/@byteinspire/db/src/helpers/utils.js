const dlog = require('debug')('inspirecloud.api:db');
const s = require('../symbols');

function isObject(o) {
    return Object.prototype.toString.call(o) === '[object Object]';
}

function isPlainObject(o) {
    let ctor, prot;

    if (isObject(o) === false) return false;

    // 未用 new 构造的 Plain Object，其 constructor 不存在
    ctor = o.constructor;
    if (ctor === undefined) return true;

    // 若 prototype 存在，则一定是用户自定义 Object
    prot = ctor.prototype;
    if (isObject(prot) === false) return false;

    // 直接创建的 Object 会有 isPrototypeOf 方法
    if (prot.hasOwnProperty('isPrototypeOf') === false) {
        return false;
    }

    return true;
}

exports.isPlainObject = isPlainObject;

exports.dlog = dlog;

/*!
 * Determines if `a` and `b` are deep equal.
 *
 * Modified from node/lib/assert.js
 *
 * @param {any} a a value to compare to `b`
 * @param {any} b a value to compare to `a`
 * @return {Boolean}
 * @api private
 */
exports.deepEqual = function deepEqual(a, b) {
    if (a === b) {
        return true;
    }

    if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
    }

    if (
        (isBsonType(a, 'ObjectID') && isBsonType(b, 'ObjectID')) ||
        (isBsonType(a, 'Decimal128') && isBsonType(b, 'Decimal128'))
    ) {
        return a.toString() === b.toString();
    }

    if (a instanceof RegExp && b instanceof RegExp) {
        return (
            a.source === b.source &&
            a.ignoreCase === b.ignoreCase &&
            a.multiline === b.multiline &&
            a.global === b.global
        );
    }

    if (typeof a !== 'object' && typeof b !== 'object') {
        return a === b;
    }

    if (a === null || b === null || a === undefined || b === undefined) {
        return false;
    }

    if (a.prototype !== b.prototype) {
        return false;
    }

    if (Buffer.isBuffer(a)) {
        if (!Buffer.isBuffer(b)) {
            return false;
        }
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0, len = a.length; i < len; ++i) {
            if (a[i] !== b[i]) {
                return false;
            }
        }
        return true;
    }
    if (Array.isArray(a)) {
        if (!Array.isArray(b)) {
            return false;
        }
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0, len = a.length; i < len; ++i) {
            if (!deepEqual(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    let ka;
    let kb;
    let key;
    let i;
    try {
        ka = Object.keys(a);
        kb = Object.keys(b);
    } catch (e) {
        // happens when one is a string literal and the other isn't
        return false;
    }

    // having the same number of owned properties (keys incorporates
    // hasOwnProperty)
    if (ka.length !== kb.length) {
        return false;
    }

    // the same set of keys (although not necessarily the same order),
    ka.sort();
    kb.sort();

    // ~~~cheap key test
    for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] !== kb[i]) {
            return false;
        }
    }

    // equivalent values for every corresponding key, and
    // ~~~possibly expensive deep test
    for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!deepEqual(a[key], b[key])) {
            return false;
        }
    }

    return true;
};

/*!
 * Get the bson type, if it exists
 */

function isBsonType(obj, typename) {
    return obj['_bsontype'] === typename;
}

exports.isBsonType = isBsonType;
exports.isObjectId = function (obj) {
    return isBsonType(obj, 'ObjectId') || isBsonType(obj, 'ObjectID');
};

exports.isRegex = function (arg) {
    return Object.prototype.toString.call(arg) === '[object RegExp]';
};

/*!
 * Determines if `arg` is a plain old JavaScript object (POJO). Specifically,
 * `arg` must be an object but not an instance of any special class, like String,
 * ObjectId, etc.
 *
 * `Object.getPrototypeOf()` is part of ES5: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf
 *
 * @param {Object|Array|String|Function|RegExp|any} arg
 * @api private
 * @return {Boolean}
 */

exports.isPOJO = function (arg) {
    if (arg == null || typeof arg !== 'object') {
        return false;
    }
    const proto = Object.getPrototypeOf(arg);
    // Prototype may be null if you used `Object.create(null)`
    // Checking `proto`'s constructor is safe because `getPrototypeOf()`
    // explicitly crosses the boundary from object data to object metadata
    return !proto || proto.constructor === {}.constructor;
};

exports.hideProps = function (obj) {
    for (let item of Object.keys(obj).filter((v) => v.startsWith('_') || v.startsWith('$_'))) {
        Object.defineProperty(obj, item, {
            enumerable: false,
            writable: false,
            configurable: false,
        });
    }
};

// https://stackoverflow.com/questions/10834796/validate-that-a-string-is-a-positive-integer
exports.isNormalIntegerStr = function (str) {
    var n = Math.floor(Number(str));
    return n !== Infinity && String(n) === str && n >= 0;
};

exports.save = async function (odms) {
    if (!odms || odms.length === 0) return;
    let tableOdmHash = new Map();
    for (let odm of odms) {
        if (!tableOdmHash.get(odm[s.table])) {
            tableOdmHash.set(odm[s.table], []);
        }
        tableOdmHash.get(odm[s.table]).push(odm);
    }
    await Promise.all(
        [...tableOdmHash].map(async ([table, odms]) => {
            await table._saveMany(odms);
        }),
    );
};

exports.detectODM = function detectODM(
    hostObj,
    detectedODMs = [],
    detectedRefSchema = {},
    detectedRefSchemaPath = '',
    remainingLevel = 3,
    doTransform = false,
) {
    if (remainingLevel === 0) return;
    if (!hostObj) return;
    let keys = Object.keys(hostObj);
    if (keys.length === 0) return;
    for (let key of keys) {
        let path = detectedRefSchemaPath ? detectedRefSchemaPath + '.' + key : key;
        let value = hostObj[key];
        if (!value) continue;
        if (value[s.table]) {
            detectedODMs.push(value);
            detectedRefSchema[path] = detectedRefSchema[path] || value[s.table].tableName;
            if (doTransform) {
                hostObj[key] = value._id;
            }
        } else if (Array.isArray(value)) {
            for (let i = 0; i < value.length; i++) {
                if (value[i] && value[i][s.table]) {
                    detectedODMs.push(value[i]);
                    detectedRefSchema[path] = detectedRefSchema[path] || value[i][s.table].tableName;
                    if (doTransform) {
                        value[i] = value[i]._id;
                    }
                }
            }
        } else if (exports.isPlainObject(value)) {
            detectODM(value, detectedODMs, detectedRefSchema, path, remainingLevel - 1, doTransform);
        }
    }
};

exports.detectODMAndTransform = function detectODMAndTransform(
    hostObj,
    newObj,
    detectedODMs = [],
    detectedRefSchema = {},
    detectedRefSchemaPath = '',
    remainingLevel = 3,
) {
    if (remainingLevel === 0) return;
    if (!hostObj) return;
    let keys = Object.keys(hostObj);
    if (keys.length === 0) return;
    for (let key of keys) {
        let path = detectedRefSchemaPath ? detectedRefSchemaPath + '.' + key : key;
        let value = hostObj[key];
        newObj[key] = value;
        if (!value) continue;
        if (value[s.table]) {
            detectedODMs.push(value);
            detectedRefSchema[path] = detectedRefSchema[path] || value[s.table].tableName;
            newObj[key] = value._id;
        } else if (Array.isArray(value)) {
            newObj[key] = [];
            for (let i = 0; i < value.length; i++) {
                newObj[key][i] = value[i];
                if (value[i] && value[i][s.table]) {
                    detectedODMs.push(value[i]);
                    detectedRefSchema[path] = detectedRefSchema[path] || value[i][s.table].tableName;
                    newObj[key][i] = value[i]._id;
                }
            }
        } else if (exports.isPlainObject(value)) {
            let newLevel = remainingLevel - 1;
            if (newLevel > 0) {
                let newObjParam = {};
                newObj[key] = newObjParam;
                detectODMAndTransform(value, newObjParam, detectedODMs, detectedRefSchema, path, remainingLevel - 1);
            }
        }
    }
};

exports.detectODMInQueryAndTransform = function detectODMInQueryAndTransform(hostObj, newObj, remainingLevel = 3) {
    if (remainingLevel === 0) return;
    if (!hostObj) return;
    let keys = Object.keys(hostObj);
    if (keys.length === 0) return;
    for (let key of keys) {
        let value = hostObj[key];
        newObj[key] = value;
        if (!value) continue;

        if (value[s.table]) {
            newObj[key] = value._id;
        } else if (Array.isArray(value)) {
            newObj[key] = [];
            for (let i = 0; i < value.length; i++) {
                newObj[key][i] = value[i];
                if (value[i] && value[i][s.table]) {
                    newObj[key][i] = value[i]._id;
                } else if (key.startsWith('$') && exports.isPlainObject(value[i])) {
                    let newObjParam = {};
                    newObj[key][i] = newObjParam;
                    detectODMInQueryAndTransform(value[i], newObjParam, remainingLevel);
                }
            }
        } else if (exports.isPlainObject(value)) {
            let newObjParam = {};
            newObj[key] = newObjParam;
            detectODMInQueryAndTransform(value, newObjParam, key.startsWith('$') ? remainingLevel : remainingLevel - 1);
        }
    }
    return newObj;
};
