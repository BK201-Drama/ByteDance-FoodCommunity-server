declare const RedisSDK: SDK.IRedisSDK;

export default RedisSDK;
export type API = SDK.IRedisSDK;

declare namespace SDK {
  interface ISDK {
    createRedisSDK(): IRedisSDK;
  }

  type BooleanResponse = 1 | 0;
  type ValueType = string | Buffer | number | any[];
  type KeyType = string | Buffer;
  type Ok = 'OK';

  interface IRedisSDK {
    bitcount(key: KeyType): Promise<number>;

    bitcount(key: KeyType, start: number, end: number): Promise<number>;

    get(key: KeyType): Promise<string | null>;

    set(
      key: KeyType,
      value: ValueType,
      expiryMode?: string | any[],
      time?: number | string,
      setMode?: number | string,
    ): Promise<string>;

    setnx(key: KeyType, value: ValueType): Promise<BooleanResponse>;

    setex(key: KeyType, seconds: number, value: ValueType): Promise<Ok>;

    psetex(key: KeyType, milliseconds: number, value: ValueType): Promise<Ok>;

    append(key: KeyType, value: ValueType): Promise<number>;

    strlen(key: KeyType): Promise<number>;

    del(...keys: KeyType[]): Promise<number>;

    exists(...keys: KeyType[]): Promise<number>;

    setbit(key: KeyType, offset: number, value: ValueType): Promise<number>;

    getbit(key: KeyType, offset: number): Promise<number>;

    setrange(key: KeyType, offset: number, value: ValueType): Promise<number>;

    getrange(key: KeyType, start: number, end: number): Promise<string>;

    incr(key: KeyType): Promise<number>;

    decr(key: KeyType): Promise<number>;

    mget(...keys: KeyType[]): Promise<Array<string | null>>;

    rpush(key: KeyType, ...values: ValueType[]): Promise<number>;

    lpush(key: KeyType, ...values: ValueType[]): Promise<number>;

    rpushx(key: KeyType, value: ValueType): Promise<number>;

    lpushx(key: KeyType, value: ValueType): Promise<number>;

    linsert(key: KeyType, direction: 'BEFORE' | 'AFTER', pivot: string, value: ValueType): Promise<number>;

    rpop(key: KeyType): Promise<string>;

    lpop(key: KeyType): Promise<string>;

    llen(key: KeyType): Promise<number>;

    lindex(key: KeyType, index: number): Promise<string>;

    lset(key: KeyType, index: number, value: ValueType): Promise<Ok>;

    lrange(key: KeyType, start: number, stop: number): Promise<string[]>;

    ltrim(key: KeyType, start: number, stop: number): Promise<Ok>;

    lrem(key: KeyType, count: number, value: ValueType): Promise<number>;

    rpoplpush(source: string, destination: string): Promise<string>;

    sadd(key: KeyType, ...members: ValueType[]): Promise<number>;

    srem(key: KeyType, ...members: ValueType[]): Promise<number>;

    smove(source: string, destination: string, member: string): Promise<BooleanResponse>;

    sismember(key: KeyType, member: string): Promise<BooleanResponse>;

    scard(key: KeyType): Promise<number>;

    spop(key: KeyType): Promise<string | null>;

    spop(key: KeyType, count: number): Promise<string[]>;

    srandmember(key: KeyType): Promise<string | null>;

    srandmember(key: KeyType, count: number): Promise<string[]>;

    sinter(...keys: KeyType[]): Promise<string[]>;

    sinterstore(destination: string, ...keys: KeyType[]): Promise<number>;

    sunion(...keys: KeyType[]): Promise<string[]>;

    sunionstore(destination: string, ...keys: KeyType[]): Promise<number>;

    sdiff(...keys: KeyType[]): Promise<string[]>;

    sdiffstore(destination: string, ...keys: KeyType[]): Promise<number>;

    smembers(key: KeyType): Promise<string[]>;

    zadd(key: KeyType, ...args: string[]): Promise<number | string>;

    zincrby(key: KeyType, increment: number, member: string): Promise<string>;

    zrem(key: KeyType, ...members: ValueType[]): Promise<number>;

    zremrangebyscore(key: KeyType, min: number | string, max: number | string): Promise<number>;

    zremrangebyrank(key: KeyType, start: number, stop: number): Promise<number>;

    zunionstore(destination: string, numkeys: number, key: KeyType, ...args: string[]): Promise<number>;

    zinterstore(destination: string, numkeys: number, key: KeyType, ...args: string[]): Promise<number>;

    zrange(key: KeyType, start: number, stop: number, withScores?: 'WITHSCORES'): Promise<string[]>;

    zrevrange(key: KeyType, start: number, stop: number, withScores?: 'WITHSCORES'): Promise<string[]>;

    zrangebyscore(
      key: KeyType,
      min: number | string,
      max: number | string,
      withScores?: 'WITHSCORES',
    ): Promise<string[]>;

    zrangebyscore(
      key: KeyType,
      min: number | string,
      max: number | string,
      withScores: 'WITHSCORES',
      limit: 'LIMIT',
      offset: number,
      count: number,
    ): Promise<string[]>;

    zrangebyscore(
      key: KeyType,
      min: number | string,
      max: number | string,
      limit: 'LIMIT',
      offset: number,
      count: number,
    ): Promise<string[]>;

    zrevrangebyscore(
      key: KeyType,
      min: number | string,
      max: number | string,
      withScores?: 'WITHSCORES',
    ): Promise<string[]>;

    zrevrangebyscore(
      key: KeyType,
      min: number | string,
      max: number | string,
      withScores: 'WITHSCORES',
      limit: 'LIMIT',
      offset: number,
      count: number,
    ): Promise<string[]>;

    zrevrangebyscore(
      key: KeyType,
      min: number | string,
      max: number | string,
      limit: 'LIMIT',
      offset: number,
      count: number,
    ): Promise<string[]>;

    zcount(key: KeyType, min: number | string, max: number | string): Promise<number>;

    zcard(key: KeyType): Promise<number>;

    zscore(key: KeyType, member: string): Promise<string>;

    zrank(key: KeyType, member: string): Promise<number | null>;

    zrevrank(key: KeyType, member: string): Promise<number | null>;

    hset(key: KeyType, field: string, value: ValueType): Promise<BooleanResponse>;

    hsetnx(key: KeyType, field: string, value: ValueType): Promise<BooleanResponse>;

    hget(key: KeyType, field: string): Promise<string | null>;

    hmset(key: KeyType, ...args: ValueType[]): Promise<BooleanResponse>;

    hmset(key: KeyType, data: object | Map<string, ValueType>): Promise<BooleanResponse>;

    hmget(key: KeyType, ...fields: string[]): Promise<Array<string | null>>;

    hincrby(key: KeyType, field: string, increment: number): Promise<number>;

    hincrbyfloat(key: KeyType, field: string, increment: number): Promise<number>;

    hdel(key: KeyType, ...fields: string[]): Promise<number>;

    hlen(key: KeyType): Promise<number>;

    hkeys(key: KeyType): Promise<string[]>;

    hvals(key: KeyType): Promise<string[]>;

    hgetall(key: KeyType): Promise<{ [key: string]: string | number }>;

    hexists(key: KeyType, field: string): Promise<BooleanResponse>;

    incrby(key: KeyType, increment: number): Promise<number>;

    incrbyfloat(key: KeyType, increment: number): Promise<number>;

    decrby(key: KeyType, decrement: number): Promise<number>;

    getset(key: KeyType, value: ValueType): Promise<string | null>;

    mset(...args: ValueType[]): Promise<Ok>;

    mset(data: object | Map<string, ValueType>): Promise<Ok>;

    expire(key: KeyType, seconds: number): Promise<BooleanResponse>;

    pexpire(key: KeyType, milliseconds: number): Promise<BooleanResponse>;

    expireat(key: KeyType, timestamp: number): Promise<BooleanResponse>;

    pexpireat(key: KeyType, millisecondsTimestamp: number): Promise<BooleanResponse>;

    ping(message?: string): Promise<string>;

    type(key: KeyType): Promise<string>;

    ttl(key: KeyType): Promise<number>;

    pttl(key: KeyType): Promise<number>;

    persist(key: KeyType): Promise<BooleanResponse>;

    restore(...args: ValueType[]): Promise<Ok>;

    dump(key: KeyType): Promise<string>;

    eval(script: string, numKeys: number, ...args: ValueType[]): any;

    evalsha(scriptSha: string, numKeys: string, ...args: ValueType[]): any;

    pfmerge(destkey: KeyType, ...sourcekeys: KeyType[]): Promise<Ok>;

    pfadd(key: KeyType, ...elements: string[]): Promise<number>;

    pfcount(...keys: KeyType[]): Promise<number>;
  }
}
