const { getType } = require('mime');
const FormData = require('form-data');
const ObjectId = require('bson').ObjectId;
const { trap } = require('@byteinspire/utils');
const Downloader = require('nodejs-file-downloader');
const { pickBy, identity } = require('lodash');
const path = require('path');

const MAX_FILE_SIZE = 30 * 1024 * 1024;

class FileSDK {
    constructor(serviceId, axiosInstance) {
        this.serviceId = serviceId;
        this.axios = axiosInstance;
    }

    async readBufferFromUrl(url) {
        const res = await this.axios({
            method: 'get',
            url,
            responseType: 'stream',
        });
        const stream = res.data;

        return new Promise((resolve, reject) => {
            stream.on('data', onData);
            stream.on('end', onEnd);
            stream.on('error', onEnd);
            stream.on('close', onClose);

            function cleanup() {
                stream.removeListener('data', onData);
                stream.removeListener('end', onEnd);
                stream.removeListener('error', onEnd);
                stream.removeListener('close', onClose);
            }

            let buffer = Buffer.from([]);
            let size = 0;

            function onData(doc) {
                size = doc.length;

                if (size > MAX_FILE_SIZE) {
                    stream.destroy(new Error('File size exceeds the limit (30M)'));
                    return;
                }

                buffer = Buffer.concat([buffer, doc]);
            }

            function onEnd(err) {
                if (err) {
                    reject(err);
                } else {
                    resolve(buffer);
                }
                cleanup();
            }

            function onClose() {
                resolve(buffer);
                cleanup();
            }
        });
    }

    genErrorStr(message, moduleName) {
        const modulePrefix = moduleName ? `[${moduleName}] ` : '';
        return `${modulePrefix}${message}`;
    }

    async upload(name, file, options = {}, addition = {}) {
        const formData = new FormData();
        let contentType = '';
        let buffer;

        if (!options.region) {
            options.region = 'cn';
        }
        if (file instanceof Buffer) {
            buffer = file;
            contentType = getType(name);
        } else if (typeof file === 'string') {
            buffer = Buffer.from(file);
            contentType = 'text/plain';
        } else if (file.url) {
            try {
                buffer = await this.readBufferFromUrl(file.url);
                contentType = getType(name);
            } catch (e) {
                throw new Error(this.genErrorStr(`Fail to get ${file.url}: ${e.message}`));
            }
        } else {
            throw new Error(`The file type '${typeof file}' is unsupported`);
        }

        /* eslint-disable-next-line */
        if (!buffer) {
            throw new TypeError(this.genErrorStr('File type not recognized'));
        }

        if (buffer.length > MAX_FILE_SIZE) {
            throw new Error(this.genErrorStr('File size exceeds the limit (30M)'));
        }

        formData.append(name, buffer, {
            filename: name,
            contentType,
        });

        if (typeof addition === 'object' && addition !== null) {
            formData.append('additions', JSON.stringify(addition));
        }

        if (typeof options === 'object') {
            formData.append('options', JSON.stringify(options));
        }

        const { data } = await this.axios({
            url: `/api/v1/services/${this.serviceId}/file`,
            method: 'POST',
            headers: { ...formData.getHeaders() },
            data: formData,
        });

        if (data.id) {
            data.id = ObjectId(data.id);
        }
        return data;
    }

    async delete(files) {
        const { data } = await this.axios({
            url: `/api/v1/services/${this.serviceId}/file`,
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
            },
            data: JSON.stringify({ files: files }),
        });
        return data;
    }

    async download(file, params) {
        let directory, fileName, onProgress;
        if (params) ({ directory, fileName, onProgress } = params);

        let query = {};
        // 判断此资源在轻服务中是否存在
        const { data } = await this.axios({
            url: `/api/v1/services/${this.serviceId}/file?file=${file}`,
            method: 'GET',
        });

        if (!data || !data.data || !data.data.url) {
            throw new Error(this.genErrorStr('the file resource not exists qingfuwu'));
        }
        query.url = data.data.url;

        if (!directory) {
            directory = '/tmp';
        } else if (directory && !/^\/tmp.*/.test(directory)) {
            throw new Error(this.genErrorStr('the download resource must save /tmp directory'));
        }
        query.directory = directory;

        let res = `${directory}/`;
        query = {
            ...query,
            fileName,
            onProgress,
            onBeforeSave: (deducedName) => {
                res = path.join(directory, deducedName);
            },
        };

        query = pickBy(query, identity);

        try {
            await new Downloader(query).download();
            return {
                filePath: res,
            };
        } catch (e) {
            console.error(e);
            return e;
        }
    }
}

const toDecorate = ['upload'];

toDecorate.map((operationName) => {
    const descriptor = Object.getOwnPropertyDescriptor(FileSDK.prototype, operationName);
    if (descriptor) {
        descriptor.value = trap(descriptor.value, false, (error) => {
            let errorMessage = error.message;
            if (error.response && error.response.data && error.response.data.message) {
                errorMessage = error.response.data.message;
            }
            return `[inspirecloud.file.${operationName}]: ${errorMessage}`;
        });
        Object.defineProperty(FileSDK.prototype, operationName, descriptor);
    }
});

function compatibleSDK(sdk) {
    const compatible = {};
    Object.setPrototypeOf(compatible, sdk);
    Object.assign(compatible, {
        async upload(name, file, options = {}, addition = {}) {
            if (typeof options === 'string') {
                // eslint-disable-next-line no-param-reassign
                options = {
                    type: options,
                };
            }
            if (!options) {
                // eslint-disable-next-line
                options = { region: 'cn' };
            } else if (!options.region) {
                // eslint-disable-next-line
                options.region = 'cn';
            }
            // eslint-disable-next-line
            const { url } = await Object.getPrototypeOf(this).upload(name, file, options, addition);
            return url;
        },
        async save(name, file, options = {}, addition = {}) {
            const formData = new FormData();
            let contentType = '';
            let buffer;

            if (file instanceof Buffer) {
                buffer = file;
                contentType = getType(name);
            } else if (typeof file === 'string') {
                buffer = Buffer.from(file);
                contentType = 'text/plain';
            } else if (file.url) {
                try {
                    buffer = await this.readBufferFromUrl(file.url);
                    contentType = getType(name);
                } catch (e) {
                    throw new Error(this.genErrorStr(`Fail to get ${file.url}: ${e.message}`));
                }
            } else {
                throw new Error(`The file type '${typeof file}' is unsupported`);
            }

            /* eslint-disable-next-line */
            if (!buffer) {
                throw new TypeError(this.genErrorStr('File type not recognized'));
            }

            if (buffer.length > MAX_FILE_SIZE) {
                throw new Error(this.genErrorStr('File size exceeds the limit (30M)'));
            }

            formData.append(name, buffer, {
                filename: name,
                contentType,
            });

            formData.append('createNewName', 1);

            if (typeof addition === 'object' && addition !== null) {
                formData.append('additions', JSON.stringify(addition));
            }

            if (typeof options === 'object' && options !== null) {
                formData.append('options', JSON.stringify(options));
            }

            const result = await this.axios({
                url: `/api/v1/services/${this.serviceId}/file`,
                method: 'POST',
                headers: { ...formData.getHeaders() },
                data: formData,
            });

            return result.data.url;
        },
    });
    const toDecorate = ['upload', 'save'];

    toDecorate.map((operationName) => {
        const descriptor = Object.getOwnPropertyDescriptor(compatible, operationName);
        if (descriptor) {
            descriptor.value = trap(descriptor.value, false, (error) => {
                let errorMessage = error.message;
                if (error.response && error.response.data && error.response.data.message) {
                    errorMessage = error.response.data.message;
                }
                return `[inspirecloud.file.${operationName}]: ${errorMessage}`;
            });
            Object.defineProperty(compatible, operationName, descriptor);
        }
    });
    return compatible;
}

module.exports = { FileSDK, compatibleSDK };
