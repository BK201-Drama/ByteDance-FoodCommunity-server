import type { Faker } from '.';
export interface Card {
    name: string;
    username: string;
    email: string;
    address: {
        streetA: string;
        streetB: string;
        streetC: string;
        streetD: string;
        city: string;
        state: string;
        country: string;
        zipcode: string;
        geo: {
            lat: string;
            lng: string;
        };
    };
    phone: string;
    website: string;
    company: {
        name: string;
        catchPhrase: string;
        bs: string;
    };
    posts: Array<{
        words: string;
        sentence: string;
        sentences: string;
        paragraph: string;
    }>;
    accountHistory: Array<{
        amount: string;
        date: Date;
        business: string;
        name: string;
        type: string;
        account: string;
    }>;
}
export interface ContextualCard {
    name: string;
    username: string;
    avatar: string;
    email: string;
    dob: Date;
    phone: string;
    address: {
        street: string;
        suite: string;
        city: string;
        zipcode: string;
        geo: {
            lat: string;
            lng: string;
        };
    };
    website: string;
    company: {
        name: string;
        catchPhrase: string;
        bs: string;
    };
}
export interface UserCard {
    name: string;
    username: string;
    email: string;
    address: {
        street: string;
        suite: string;
        city: string;
        zipcode: string;
        geo: {
            lat: string;
            lng: string;
        };
    };
    phone: string;
    website: string;
    company: {
        name: string;
        catchPhrase: string;
        bs: string;
    };
}
export interface Transaction {
    amount: string;
    date: Date;
    business: string;
    name: string;
    type: string;
    account: string;
}
export declare class Helpers {
    private readonly faker;
    constructor(faker: Faker);
    /**
     * backward-compatibility
     *
     * @method faker.helpers.randomize
     * @param array
     */
    randomize<T = string>(array?: ReadonlyArray<T>): T;
    /**
     * slugifies string
     *
     * @method faker.helpers.slugify
     * @param string
     */
    slugify(string?: string): string;
    /**
     * Parses string for a symbol and replace it with a random number from 1-10
     *
     * @method faker.helpers.replaceSymbolWithNumber
     * @param string
     * @param symbol defaults to `"#"`
     */
    replaceSymbolWithNumber(string?: string, symbol?: string): string;
    /**
     * Parses string for symbols (numbers or letters) and replaces them appropriately (# will be replaced with number,
     * ? with letter and * will be replaced with number or letter)
     *
     * @method faker.helpers.replaceSymbols
     * @param string
     */
    replaceSymbols(string?: string): string;
    /**
     * replace symbols in a credit card schems including Luhn checksum
     *
     * @method faker.helpers.replaceCreditCardSymbols
     * @param string
     * @param symbol
     */
    replaceCreditCardSymbols(string?: string, symbol?: string): string;
    /**
     * String repeat helper, alternative to String.prototype.repeat.... See PR #382
     *
     * @method faker.helpers.repeatString
     * @param string
     * @param num
     */
    repeatString(string: string, num?: number): string;
    /**
     * parse string patterns in a similar way to RegExp
     *
     * e.g. "#{3}test[1-5]" -> "###test4"
     *
     * @method faker.helpers.regexpStyleStringParse
     * @param string
     */
    regexpStyleStringParse(string?: string): string;
    /**
     * Takes an array and randomizes it in place then returns it
     *
     * Uses the modern version of the Fisherâ€“Yates algorithm
     *
     * @method faker.helpers.shuffle
     * @param o
     */
    shuffle<T>(o?: T[]): T[];
    /**
     * Takes an array of strings or function that returns a string
     * and outputs a unique array of strings based on that source
     *
     * @example uniqueArray(faker.random.word, 50)
     * @example uniqueArray(faker.definitions.name.first_name, 6)
     * @example uniqueArray(["Hello", "World", "Goodbye"], 2)
     *
     * @method faker.helpers.uniqueArray
     * @param source
     * @param length
     */
    uniqueArray<T>(source: T[] | (() => T), length: number): T[];
    /**
     * mustache
     *
     * @method faker.helpers.mustache
     * @param str
     * @param data
     */
    mustache(str: string | undefined, data: Record<string, string | ((substring: string, ...args: any[]) => string)>): string;
    /**
     * createCard
     *
     * @method faker.helpers.createCard
     */
    createCard(): Card;
    /**
     * contextualCard
     *
     * @method faker.helpers.contextualCard
     */
    contextualCard(): ContextualCard;
    /**
     * userCard
     *
     * @method faker.helpers.userCard
     */
    userCard(): UserCard;
    /**
     * createTransaction
     *
     * @method faker.helpers.createTransaction
     */
    createTransaction(): Transaction;
}
